<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Web 3 Development</title>
    <link rel="stylesheet" href="/style.css">
</head>
<body>
    <h1 class = "title">Web 3 Development</h1>
    <section>
       <h2>Commencez ici</h2> 
       <div class="content-section">
           <div class="content-title">
                <h3 >Introduction</h3>
                <div class="content-details">
                    <p>Incredible potential of blockchain - both as cryptocurrency system and as a development platform.</p>
                    <p>Combine all technologies, that make up the Etherium blockchain development eco system.</p>
                    <p> Course Structure</p>
                    <ul>
                        <li>Blockchain Philisophy </li>
                        <li>How does a blockchain work?</li>
                        <li>Cryptography fundamentals</li>
                        <li>Environemnt development</li>
                        <li>Building a Dapp from scratch</li>             
                </div>
           </div>
       </div>
    </section>
    <section>
        <h2>Why The Blockchain?</h2> 
        <div class="content-section">
            <div class="content-title">
                 <h3 >How Do You Represent Value</h3>
                 <div class="content-details">
                    <p>Network of Information</p>
                    <ul>
                        <li>Internet is Network of Information where data is transmitted from node to node through <u>copy</u>.</li>
                        <li>Once data is injected into the internet, it replicates and spreads rapidly and will never be unique again.</li>
                    </ul>
                    <p>Network of Value</p>
                    <ul>
                        <li>Value should be transferred as a <u>move</u>, not as a copy.</li>
                        <li>Not only about monetary value, but e.g. documents of ownership.</li>
                        <li>Have to avoid double spending of the same value/money/assets. Some ways for that:</li>
                            <ul>
                                <li><i>Notes</i>: Physical Value, anonymous and trustable. Creating it costs money. Losing it means it is gone forever </li>
                                <li><i>Ledgers</i>: Record book, keep track of value without physical. Need to keep track - not so security</li>
                            </ul>
                    </ul>
                    <p>The Compensation Process</p>
                    <ul>
                        <li>Digital ledgers: Digital system of value storage and transfer (for banks)</li>
                        <li>Each bank keeps its own ledger.</li>
                        <li>Need to synchronize all these seperate ledgers.</li>
                        <li>Banking system is a set of centralized databases of transactions</li>
                    </ul>
                 </div>
            </div>
            <div class="content-title">
                <h3 >The Internet of Value</h3>
                <div class="content-details ">
                    <p>An example of power gone bad</p>
                    <ul>
                        <li>Bank lends money and adds transaction to it's own ledger</li>
                        <li>The money lent did not really exist before. It was created via <b>debt</b></li>
                        <li>Banks are legally allowed to land more money than they have if they protect their risk</li>
                        <li>That's why there are interests proportional to the risk</li>
                        <li>In the bank crisis, banks started to lend money to households who will have difficult time paying it back.</li>
                        <li>Banks started to create very sophisticated financial products, that repackaged those risky debts and asked partners to rate those <b>CDOs</b> (collateral debt obligations) with very safe <b>triple A ratings</b></li>
                        <li>When lenders couldn't pay the mortgages back, everything collapsed</li>
                    </ul>
                    <p>The Birth of Bitcoin</p>
                    <ul>
                        <li>2008 November - same time of financial crisis</li>
                        <li>New kind of monetary system - create and store value in completely digital form. Fully decentralized.</li>
                    </ul>
                    <p>The Byzantine Generals' Problem</p>
                    <ul>
                        <li>City surrounded by several armies</li>
                        <li>Decision to attack the city or leave</li>
                        <li>If everybody decides to attack, city will fall apart.</li>
                        <li>If only few decided to attack they will all get butchered</li>
                        <li>Can only communicate using horse messengers who can lie, get corrupted</li>  
                    </ul>
                    <p>Centralized ledger</p>
                    <ul>
                        <li>One special node that is recognized as a source of truth.</li>
                    </ul>
                    <p>Distributed ledger</p>
                        <ul>
                            <li>What happens if you loose the centralized point of decision?</li>
                            <li>Bitcoin was the first to propose a solution for this.</li>
                        </ul>
                    <p>To infinity and beyond..</p>
                    <ul>
                        <li>If Bitcoin could provide the decentralized solution for money, could it be applied to other assets as well (e.g. insurances, contracts) etc.</li>
                    </ul>
                </div>
           </div>
           <div class="content-title">
                <h3 >Blockchain Use Cases</h3>
                <div class="content-details">
                    <p>FinTech is the initial area for blockchain (as currency)</p>
                    <p>Selling a good or a service</p>
                    <ul> 
                        <li>Selling a car / wiring the value in currency, receiving physical asset - car</li>
                        <li>Selling a house: wiring the value in currency, receiving ownership of the house (via ledger that keeps the transaction details)</li>
                        <li>Selling electricity: produce electricity (physicial records), keep a ledger with all the details, where it goes and who uses it</li>
                    </ul>
                    <p>A currency transaction</p>
                    <ul>
                        <li>Origin / Destination / Value / State</li>
                        <li>Simple logic: if the balance is greater than the amount, decrease it and add it to the others persons account </li>
                        <li>With Bitcoin (currency), same program applies for all transactions.</li>
                    </ul>
                    <p>A generic transaction</p>
                    <ul>
                        <li>More variables, more tests, more loops.</li>
                    </ul>
                    <p>Smart Contracts</p>
                    <ul>
                        <li>Programs that are stored on the blockchain itself and functions of those programs are executed in transactions</li>
                        <li>The transactions can have different sizes etc.</li>
                    </ul>
                    <p>Smart Contract Use Cases</p>
                    <ul>
                        <li>Copy rights</li>
                        <li>Contracts for lawyers</li>
                        <li>Votes for congress</li>
                        <li>Invoices for accountants </li>
                        <li>Bets for a game</li>
                        <li>Shares in a company</li>
                        <li>...any kind of value that is today kept in a ledger</li>
                    </ul>
                    <p>Disintermediation</p>
                    <ul>
                        <li>Without blockchain, you need a trusted party for centralized control.</li>
                    </ul>
                </div>
            </div>
        </div>
     </section>
     <section>
        <h2>What is a blockchain (and what it's not)?</h2> 
        <div class="content-section">
            <div class="content-title">
                 <h3>The 3-layer Model</h3>
                 <div class="content-details">    
                     <p><u>The technology behind Bitcoin:</u> the receiver generates a new key pair and gives the public key to the sender shortly before signing. This prevents the sender from preparing a <b>chain of blocks</b> ahead of time by working on it continously until he is lucky enough to get far enough ahead, then executing the transaction at the moment.</p> 
                     <p>The 3-layer model</p> 
                     <ul>
                         <li>Design goals: properties you wish the software system to have. E.g. distribution, decentralization, peer-to-peer </li>
                         <li>Implementations: implement the above mentioned goals in a certain way (typically same protocol on how nodes should collaborate)</li>
                         <li>Instances: different networks working side by side to create a ledger.</li>
                     </ul>          
                 </div>
            </div>
            <div class="content-title">
                <h3>Blockchain Design Goals</h3>
                <div class="content-details">  
                    <p>Peer-to-peer data distribution</p> 
                    <ul>
                        <li>Data itself and processes to read and modified the data</li>
                        <li>In centralized setup, if the data storage is lost, it's gone forever. Here comes the distribution.</li>
                        <li>Distribute several copies of it in a way that if one node fails, you can still retreive the data.</li>
                        <li>Only one node can modify the data, all others can keep a copy and synchronize it in read-only node.</li>
                        <li>Everyone can potentially see and verify the entire dataset. Creates issues with privacy though. This is solved with pseudonimity.</li>
                        <li>Scalability issue: volume of data. All modificiations are stored.</li>
                    </ul> 
                    <p>Decentralization</p>
                    <ul>
                        <li>If there is only one centralized point of modifications, it still is a weakness - if this point fails, the whole system stops working</li>
                        <li>If each node has power of modifying and applying changes, then its almost impossible to take it down. </li>
                        <li>Issue with consistency - if all the nodes can modify the data in the way they want it, how do you ensure that they all work in the same way?</li>
                        <li>In blockchain it is solved by <b>consensus algorithm</b>: change the owner of the changes randomly all the time</li>
                    </ul>  
                    <p>Immutability</p> 
                    <ul>
                        <li>Changing historical data is a risk.</li>
                        <li>Only thing you can do is append transactions</li>
                    </ul> 
                    <p>Trustless Environment</p> 
                    <ul>
                        <li>Nodes can join the network at any time and start making changes without needing to trust them. </li>
                        <li>Trust should be build in the system.</li>
                    </ul>       
                </div>
           </div>
           <div class="content-title">
                <h3>Blockchain Implementations</h3>
                <div class="content-details"> 
                    <p>In <u>Bitcoin</u> peer-to-peer distribution, decentralization and immutability is created in completely trustless environment</p>   
                    <ul>
                        <li>Basic element that transactions are keeping track of: Unspend Transaction Output (UTXO) - digital equivalent of a check.</li>
                        <li>Bitcoin takes non-cashed checks as inputs, makes a transaction and produces non-cashed checks as outputs.</li>
                        <li>Any node in the network can create and sign these transactions</li>
                        <li>Every 10 minutes, there is a competition, which node will append which transactions. This happens automatically.</li>
                        <li>To make the process more efficient, transactions are grouped in blocks of transations</li>
                        <li>The nodes are motivated to participate because the winner of the transaction includes one transaction to send it to himself.
                            <ul>
                                <li>This is the only way how the currency actually gets created</li>
                                <li>It incentivizes miners to do the best work.</li>
                            </ul>
                        </li>
                    </ul>
                    <p>Implementation Artifacts</p>
                    <ul>
                        <li>There can be several coding languages, but they should all have the same protocols and algorithms. So that a code created by any version, is accepted by any other version</li>
                        <li>This code is usually open-source.</li>
                        <li>Easy to create new blockchain</li>
                    </ul>
                    <p>The Ethereum Implementation</p>
                    <ul>
                        <li>More opportunities than just a currency system</li>
                        <li>If you made the variables even more generic, you can turn it into generic, decentralized, distributed computer: whether on top of blockchain (sidechain) or a part of complete new implementation - that's Ethereum </li>
                        <li>All the same principles as Bitcoin, adds a few more and does it slightly differently.</li>
                        <li>In Ethereum there are no UTXOs because it stores the balance after each block</li>
                        <li>In Ethereum the block schedule is 17s</li>
                        <li>In Ethereum transactions can have some code attached to them - this allows to execute more sophisticated pieces of logic: <b>smart contracts</b></li>
                        <li>To make sure that these smart contracts do not overload the system, you have to pay a small fee, called "Ether". </li>
                        <li>Ethereum is working on changing the "proof of consensus" algorithm to "<b>proof of stake</b>" algorithm</li>
                    </ul>
                    <p>Permissioned "blockchains"</p>
                    <ul>
                        <li>Bitcoin is a trustless environment</li>
                        <li>Some implementations get rid of some of the principles. They control who gets in.</li>
                    </ul>
                </div>
            </div>
            <div class="content-title">
                <h3>Blockchain Instances</h3>
                <div class="content-details"> 
                    <p>The genesis block</p>  
                    <ul>
                        <li>Blockchain is based on a data structure, that stores the information of all the modifications on a state, where operations are bundled in ordered blocks.</li>
                        <li>A blockchain protocol builds up a blockchain history - genesis block</li>
                        <li>The only one without any predecessor, so there is no information it can pick up</li>
                        <li>You have to create this genesis block and then spread it further: <b>instantiation</b> </li>
                        <li>The chain of blocks build on top of this genesis block is called an <b>instance</b></li>
                    </ul>   
                    <p>The Ethereum example</p>    
                    <ul>
                        <li>Every implementation has a main instance: the main net</li>
                        <li>There are some test chains (nets): Morden, Ropsten to connect and test your own applications</li>
                        <li>Your own private nets</li>
                        <li>Cryptocurrency created on one instance, cannot be used on another instance.</li>
                    </ul>  
                    <p>The notion of a fork</p>    
                    <ul>
                        <li>Based on one single genesis block, the network (ledger) starts diverging after a given block if changes are made</li>
                    </ul>
                    <p>The 3-layer model</p>
                    <ul>
                        <li>Design goals: distributed, decentralized, immutable, trustless</li>
                        <li>Implementations: Ethereum, Bitcoin, Hyperledger Fabric</li>
                        <li>Instances: Main Net, Test Nets, private nets, etc.</li>
                    </ul>
                </div>
           </div>
           <div class="content-title">
                <h3>Public Blockchains as Tricameral Systems</h3>
                <div class="content-details">                
                    <p>Open vs Permissioned</p>
                    <ul>
                        <li>Permissioned Blockchains barely qualify as blockchains as it does not follow the decentralization design goal</li>
                    </ul>
                    <p>Open Blockchains as tricameral systems</p>
                    <ul>
                        <li>Developers:
                            <ul>
                                <li>Designing the protocol</li>
                                <li>Implementing protocol in software clients</li>
                                <li>Most of these developments are open source</li>
                                <li>Important strategic decisions</li>
                                <li>Key role of the governance</li>
                            </ul>
                        </li>
                        <li>Miners
                            <ul>
                                <li>Use a special wallet software</li>
                                <li>Resource intensive process to contribute to network (work on the puzzle)</li>
                                <li>Also play a role in the governance</li>
                            </ul>
                        </li>
                        <li>Users
                            <ul>
                                <li>Account holders</li>
                                <li>Install software clients</li>
                                <li>Submits transactions to the networks</li>
                                <li>Can freely connect and disconnect and use different wallets</li>
                            </ul>
                        </li>
                    </ul>
                </div>
            </div>
            <div class="content-title">
                <h3>Blockchain Key Components 1</h3>
                <div class="content-details"> 
                    <p>A peer-to-peer network DB</p>  
                    <ul>
                        <li>Constitutes the first large scale fusion with a database with a network.</li>
                    </ul> 
                    <p>A node software client</p> 
                    <ul>
                        <li>Peer-to-peer network of nodes, that each run a software that can store data, run some transactions to update the data and connect with its peers to download and spread new data</li>
                    </ul>
                    <p>Different forms of nodes</p>  
                    <ul>
                        <li> Storing your wallet in remote database and creating transactions on your behalf (e.g. coinbase) (more practical)
                        </li>
                        <li>Use external storage or hardware (more secure) </li> 
                    </ul>  
                    <p>A wallet with keys</p>     
                    <ul>
                        <li>Wallet is the only key to joining the network</li>
                    </ul>  
                    <p>A ledger</p>
                    <ul>
                        <li>First download verified copy, then create transactions based on the truth (series of blocks containing series of transactions)</li>
                        <li>Extremely difficult to change historical transactions - transaction finality.</li>
                        <li>51% attack - one mining node should have more than the entire networks power in order to be faster than the rest of the network in creating fraudulent transactions and blocks</li>
                    </ul>
                    <p>A consensus algorithm</p>
                    <ul>
                        <li>Simple user nodes do not need to particpate in the consensus algorithm</li>
                        <li>Mechanism for mining</li>
                        <li>Proof of work - contributing power (hash rate)</li>
                        <li>This algorithm can be seen as a game to decide who is gonna be the next node to process the network history</li>
                        <li>Combination of cryptographic mechanisms</li>
                        <li>Proof of Work algorithms have processing issues (electricity).</li>
                    </ul>
                </div>
            </div>
            <div class="content-title">
                <h3>Blockchain Key Components 2</h3>
                <div class="content-details"> 
                    <p>A cryptocurrency</p>   
                    <ul>
                        <li>Built-in cryptocurrency.</li>
                        <li>Incentivize miners to do the security bidding (reward)</li>
                        <li>The more people trust a given blockchain implementation, the bigger its own network gets </li>
                        <li>Currency has to be: durable, portable, acceptable, limited in supply, divisible and fungible</li>
                        <li>Each transaction has transaction fees. They are also collected by the miner of the block</li>
                    </ul> 
                    <p>A smart contract language</p>     
                        <ul>
                            <li>Small piece of computer code attached to each transaction to implement more sophisticated transaction mechanism</li>
                            <li>For Bitcoin the language is voluntarily limited (not allowing loops) for processing power </li>
                            <li>For Ethereum you have a special language with all the necessary tools to create different logics. </li>
                            <li>There is a mechanism for Ethereum to measure GAS (maximum power/also transaction fee).</li>
                            <li>EVM - Etherium Virtual Machine: Code is processed in this byte language. Developers use Solidity to write code</li>
                        </ul>      
                </div>
            </div>
            <div class="content-title">
                <h3>What a Blockhain is not</h3>
                <div class="content-details">   
                    <p>Hint: <b>it's not a solution to every problem</b></p>      
                    <p>Privacy</p>       
                    <ul>
                        <li>Every node has access to all the data</li>
                    </ul>
                    <p>Pseudonimity</p>
                    <ul>
                        <li>Users can hide behind wallet addresses</li>
                        <li>Content of transaction can be seen though</li>
                    </ul>
                    <p>Transaction costs</p>
                    <ul>
                        <li>Miners need to be incentivized</li>
                        <li>For Bitcoin it's every 4 years</li>
                        <li>Every modification in blockchain comes at a cost</li>
                    </ul>
                    <p>Transaction speed</p>
                    <ul>
                        <li>In centralized system its basically immediate</li>
                        <li>In decentralization, there are many processes. For Bitcoin is 10 min or 1 hour to be sure.</li>
                        <li>For Ethereum its 17 seconds / 3.5 minutes until its final.</li>
                    </ul>
                    <p>Throughput (volume)</p>
                    <ul>
                        <li>The bigger the block, the longer it takes to calculate it.</li>
                        <li>In Bitcoin its max 1MB, in Ethereum 4 millions gas</li>
                    </ul>
                    <p>Evolutivity</p>
                    <ul>
                        <li>Platform evolution. Changing thousands of nodes, machines that are not even connected (called forks)</li>
                    </ul>
                    <p>Blockchain size</p>
                    <ul>
                        <li>Full copy of ledger keeps growing and growing</li>
                        <li>Bitcoin (112 GB) and growing 4GB a month</li>
                        <li>Ethereum (40GB) and growing 2GB a month</li>
                    </ul>
                </div>
            </div>
           </div>
       </div>
        </div>
     </section>
     <section>
        <h2>Cryptography 101</h2> 
        <div class="content-section">
            <div class="content-title">
                 <h3>Hashing Functions</h3>
                 <div class="content-details">   
                     <p>Goal: to guarantee the integrity of data in decentralized and distributed environment</p>
                     <p>Principle: Takes arbitrary volume of data as input and produces number as output</p> 
                     <p>Properties</p>  
                     <ul>
                         <li><u>Defined Range:</u> output will always have the same size, whatever the size of the input</li>
                         <li><u>Deterministic:</u>  the same input will always give the same output</li>
                         <li><u>Discontinuous:</u> the slightest difference in the input, will give completely different output</li>
                         <li><u>Uniform:</u> for any set of inputs, corresponding outputs should be distributed as evenly as possible accross the possible range of outputs. </li>
                         <li><u>Non-invertible:</u> should be impossible to find the input based on the output</li>
                     </ul>   
                     <p>Usage</p>     
                     <ul>
                         <li>Prove that given piece of content has not been tempered with</li>
                         <li>Easier to compare hashes that big inputs with variable length</li>
                         <li>Finding a coliding input</li>
                         <li>To chain block together
                             <ul>
                                 <li>Every hash has to have certain number of zero's at the beginning of the hash (it has to be smaller than difficulty target)</li>
                                 <li>Each block contains an arbitrary number, called "nonce" that you can set yourself</li>
                                 <li>Proof-of-Work</li>
                             </ul>
                         </li>
                     </ul> 
                     <p>Hashing methods</p>
                     <ul>
                         <li>Bitcoin uses SHA-256 for hashing</li>
                         <li>Ethereum uses Keccak-256 / Keccak-512</li>
                     </ul>
                 </div>
            </div>
            <div class="content-title">
                <h3>Asymmetric Cryptography</h3>
                <div class="content-details">   
                    <p>General Principle</p>  
                    <ul>
                        <li>Process that uses pair of related keys in order to transfer some readable content to make it unreadable and vice versa </li>
                        <li>Used in two scenarios:
                            <ul>
                                <li>Authentication: to prove that some given data originates from a given user</li>
                                <li>Data Confidentiality: to ensure that only the recipient of a given message can actually access its real contents</li>
                            </ul>
                        </li>
                        <li>A public key encryption algorithm takes the private key and original content as inputs and produces output</li>
                        <li>The only way to recover the original content is to reverse the process using the associated public key for the decryption process</li>
                        <li>The keys are related (from the private one, the public one is generated). But you cannot recover the private key from the public one</li>
                    </ul>    
                    <p>Digital Signature</p>    
                    <ul>
                        <li>You want to prove that a given message really comes from you</li>
                        <li>You start by hasing this message by using a hashing function to get a defined length hash</li>
                        <li>You encrypt that hash with your private key</li>
                        <li>You send the original message together with the encrypted hash (called signature)</li>
                        <li>The recipient knows your public key, so he can verify that you were able to produce that signature with the corresponding private key</li>
                    </ul>   
                    <p>RSA vs ECDSA</p>
                    <ul>
                        <li>RSA
                            <ul>
                                <li>Older Cryptography, not so used anymore</li>
                                <li>Signature Process takes the original message, the encrypted hash and public key as inputs.</li>
                            </ul>
                        </li>
                        <li>ECDSA
                            <ul>
                                <li>Elyptic Curve</li>
                                <li>Higher Levels of Security with smaller keys than RSA</li>
                                <li>Signature Process also takes the original messages, encrypted hash and the public key, but it compared the inputs differently (Recovers the public key)</li>
                            </ul>
                        </li>
                    </ul>
                    <p>Usage in Blockchain</p>
                    <ul>
                        <li>Unspend Transaction Outputs (UTXOs) in Bitcoin are linked to users through their wallet address (which is a hash of users public key) </li>
                        <li>Private key is not accessible to anyone</li>
                        <li>In online places like Coinbase, your key is actually stored in an online database, not available to anyone</li>
                    </ul>
                </div>
           </div>
           <div class="content-title">
            <h3>Merkle Trees</h3>
            <div class="content-details">  
                <p>Data Stucture / Hash Tree</p>   
                <p>Naive block hashes</p>          
                <ul>
                    <li>Hash the entire block (transactions) at once</li>
                    <li>But this block can be big and you will need to wait for all transactions to be there before calculating the hash (on miners side)</li>
                    <li>You would need to download the whole block to verify its integrity (on users side)</li>
                </ul> 
                <p>Merkle Tree</p>
                <ul>
                    <li>Calculate hash (h1- h8) for each transaction (t1-t8)</li>
                    <li>Calculate a hash of (h1+h2) and you get a new hash (h12)</li>
                    <li>Do the same for each pair and repeat the process</li>
                    <li>When all the concatenations are done, you get a root hash</li>
                </ul>
                <p>Modification impact</p>
                <ul>
                    <li>If only one transaction changes, the root hash is completely different</li>
                    <li>Two identical root hashes correspond to identical blocks</li>
                    <li>You can calculate the hash progressivly as your receive the transactions</li>
                </ul>
                <p>Partial Verification</p>
                <ul>
                    <li>To verify the integrity of t5 you would need to get h5 and h6 to get h56 and some other things to calculate the root hash</li>
                </ul>
                <p>Usage</p>
                <ul>
                    <li>Bittorrent</li>
                    <li>Git</li>
                    <li>Bitcoin</li>
                    <li>Ethereum</li>
                </ul>
                <p>Only the root hash is stored in the blockchain itself (less storage)</p>
                <p>Three Mercle Tree rules for Ethereum Blocks</p>
                <ul>
                    <li>For transactions</li>
                    <li>For state</li>
                    <li>For transaction receipts</li>
                </ul>
                <p>Ethereum uses special Mercle Tree - Patricia tree</p>
                <p>Crypto blockchain demo</p>
                <ul>
                    <li>anders.com/blockchain</li>
                </ul>
            </div>
       </div>
        </div>
     </section>
     <section>
        <h2>Installing the Development Environment (Truffle 4)</h2> 
        <div class="content-section">
            <div class="content-title">
                 <h3>MacOS environment setup</h3>
                 <div class="content-details">    
                     <p>Toolbox</p>      
                     <ul>
                         <li>Geth</li>
                         <li>Ganache</li>
                         <li>Truffle</li>
                         <li>Atom</li>
                     </ul>  
                     <p>Prerequisites</p> 
                     <ul>
                        <li>HomeBrew - package manager to install and update packages. </li>
                        <li>First you need to install XCode (on app store) and start the application to accept the T&Cs. Then quit the Xcode.<</li> 
                        <li>In the terminal "xcode-select --install"</li>
                        <li>Install HomeBrew: 
                            <ul>
                                <li>https://brew.sh</li>
                                <li>copy the code and run it in the terminal</li>
                                <li>run "brew --version" to check that you have it now</li>
                            </ul>
                        </li>
                     </ul>
                     <p>Intall Geth (aka go-ethereum)</p>   
                     <ul>
                         <li>Command Line interface that allows to run and operate full ethereum node.</li>
                         <li>Geth is implemented in Go adn allows you to mine blocks, to generate Ether, to deploy and interact with smart contracts, to transfer funds, to inspect block history, to create accounts and do all the things that are needed for managing Ethereum node</li>
                         <li>Geth can be used to connect to the public Ethereum Network (main net) or to create your own private network for development purposes</li>
                         <li>Let's you fully test your application before deploying it to the live network.</li>
                         <li>Install using Homebrew:
                             <ul>
                                 <li>Connect Homebrew to the repository providing Geth: 1."brew update", 2."brew tap ethereum/ethereum", 3."brew install ethereum" </li>
                                 <li>"brew upgrade ethereum" if you need to update the version</li>
                             </ul>
                         </li>
                     </ul>
                     <p>Install Ganache</p>
                     <ul>
                         <li>Ethereum blockchain emulator that you can use for development purposes</li>
                         <li>Can be seen as a replacement for "Test RPC", which were used in previous versions of the course</li>
                         <li>UI that allows to inspect blocks and transactions in a user friendly way</li>
                         <li>Compared to Geth, Ganache is an "in-memory" Ethereum node, that runs faster and provides all the visual components for testing your contracts locally before deploying them to real Ethereum application</li>
                         <li>http://truffleframework.com/ganache - download the app from here</li>
                     </ul>
                     <p>NodeJS and NPM</p>
                     <ul>
                         <li>NodeJS - server side JS platform to create applications that will interact with your Ethereum node</li>
                         <li>When we install Node, we also install the Node Package Manager: NPM, that is required to set up and install most of the tools to develop Ethereum.</li>
                         <li>Check if you already have it installed: "node -v" and "npm -v"</li>
                     </ul>
                     <p>Truffle 4</p>
                     <ul>
                         <li>To compile, test and compile smart contracts you will need a built framework that will increase your development velocity compared to doing it manually.</li>
                         <li>https://truffleframework.com</li>
                         <li>This version of Truffle embeds Truffle develop - a development blockchain that you can use to speed up your automated testing and your development lifecycle</li>
                         <li>"npm install -g truffle@4.0.4" to install</li>
                         <li>"truffle version" to see which version was installed</li>
                     </ul>
                     <p>Atom</p>
                     <ul>
                         <li>Text Editor to Edit Smart Contracts and Text Files</li>
                         <li>"https://github.com/atom/atom" - go to releases and download "atom-mac.zip"</li>
                         <li>Open it up, drag it to Applications</li>
                         <li>Install Shell Commands from Atom options</li>
                         <li>"apm install language-ethereum" install plugin for Solidity</li>
                     </ul>
                 </div>
            </div>
            <div class="content-title">
                <h3>Setting Up private node on MacOS</h3>
                <div class="content-details">   
                    <p>Truffle and Ganache can easily emulate Ethereum node (fake nodes) for development purposes</p>  
                    <p>Keep in mind, that they are just emulators and provide the same interface as Ethereum node deployed in public Ethereum network, but internally they work completely differently</p>     
                    <p>If you want to ensure that your contract will run properly on the main network, it is highly recommended to test it with full Ethereum node</p>      
                    <p>In this lecture, we will install a private Ethereum instance with Geth on MacOs.</p>
                    <p>Create a folder that will host the database and accounts for the private node.</p>
                    <ul>
                        <li>In terminal "mkdir -p ChainSkills/private"</li>
                        <li>Navigate to this directory</li>
                    </ul>
                    <p>Before we create the private instance, need to define a Genesis block</p>
                    <ul>
                        <li>Create it using a tool, called Puppeth</li>
                        <li>Run "puppeth" in terminal and provide the settings</li>
                        <li>Network Name: "chainskills"</li>
                        <li>What to do: "Configure new genesis - create from scratch"</li>
                        <li>Consensus: "Proof of Work"</li>
                        <li>Should be prefunded: Enter</li>
                        <li>Network ID: 4224</li>
                        <li>What to do: "Manage Existing Genesis, Export Genesis Configurations"</li>
                    </ul>
                    <p>JSON file</p>
                    <ul>
                        <li>"atom chainskills.json"</li>
                        <li>"config" section defines parameters for the chain. Contains network ID (chainID) and block numbers from which to apply rules</li>
                        <li>"timestamp" used by Ethereum Virtual Maschine to adjust the level of difficulty that must be applied. Also used to ensure that blocks are in the right order</li>
                        <li>"extraData" any information that we want to label our blockchain instance</li>
                        <li>"gasLimit" to limit the processing power and size of blocks.</li>
                        <li>"difficulty" that is needed to verify a block</li>
                        <li>"parentHash" parent node hash</li>
                    </ul>
                    <p>Initialize Private Node</p>
                    <ul>
                        <li>Quit Atom</li>
                        <li>"geth --datadir private init chainskills.json" creates "geth" and "keystore" directories</li>
                        <li>"geth" will store the blockchain instance data and "keystore" will store all accounts</li>
                    </ul>
                    <p>Prepare the instance for mining and usage</p>
                    <ul>
                        <li>Create 3 accounts - one to receive mining awards and the other two will act as the buyer/seller</li>
                        <li>"geth --datadir . account new" and set up a password</li>
                        <li>The accounts are created and have unique addresses now</li>
                        <li>Private Keys are listed under "keystore" directory.</li>
                        <li>"geth --datadir . account list" to get the order of the listed accounts</li>
                    </ul>
                    <p>Create a starting script</p>
                    <ul>
                        <li>create file "startnode.sh" with the script</li>
                        <li>make the file executable "chmod +x startnode.sh"</li>
                        <li>start private node "./startnode.sh"</li>
                        <li>It has to create all DAG and will start mining after</li>
                    </ul>
                    <p>Connect to the node from outside world</p>
                    <ul>
                        <li>"geth attach"</li>
                        <li>You will have all the details here</li>
                        <li>"eth.accounts" - accounts registered on the node</li>
                        <li>"eth.coinbase" - main address for mining rewards</li>
                        <li>"> eth.getBalance(eth.accounts[1])" Balance from mining in Wei currency</li>
                        <li>"web3.fromWei(eth.getBalance(eth.coinbase),"ether")" Convert from Wei to Ether</li>
                        <li>"miner.start" / "miner.stop"</li>
                        <li>"net version"</li>
                        <li>"> personal.unlockAccount(eth.accounts[1],"password",300)"</li>
                        <li>"eth.sendTransaction({from: eth.accounts[0], to: eth.accounts[1], value: web3.toWei(10,"ether")})" </li>
                        <li>quit by typing "exit"</li>
                    </ul>
                </div>
           </div>
            <div class="content-title">
                <h3>Setting Up MetaMask on all environments</h3>
                <div class="content-details">   
                    <p>So far we interacted with Ganache and the private node through CLI</p>      
                    <p>Later we will combine Smart Contracts and a web interface into a Dapp - Decentralized Application that people will be able to use through a special kind of web browser called "Dapp Browser"</p>  
                    <p>Dapp Browser is a web browser connected to an Ethereum node that can manage a set of keys</p>   
                    <p>There are not a lot of Dapp browsers, most common ones are Mist and Metamask that works in Chrome and Firefox as an extension</p> 
                    <p>Install MetaMask extension</p>
                    <ul>
                        <li>https://metamask.io/ - Download and add as extension for Chrome</li>
                    </ul>
                    <p>Initialize the vault</p>
                    <ul>
                        <li>Metamask uses vault concept to store the keys that correspond to your account</li>
                        <li>Ganache generates 10 accounts by default, that will always be identical if we keep the default settings. </li>
                        <li>Seedphrase stored in .env file.</li>
                        <li>Never use that seedphrase in the import existing metamask</li>
                        <li>Create a new wallet and get your seedphrase. Store it in your password manager</li>
                    </ul>
                    <p>Import accounts from Ganache</p>
                    <ul>
                        <li>Start Ganache and you will see the 10 accounts that were generated</li>
                        <li>In MetaMask add a new network with host: "http://localhost:7545"</li>
                        <li>Import all the accounts one by one</li>
                        <li>This might take longer and is a bit buggy</li>
                        <li>https://github.com/MetaMask/faq</li>
                    </ul> 
                    <p>Import all the accounts from the private node</p>
                    <ul>
                        <li>cd ChainSkills/private</li>
                        <li>./startnode.sh</li>
                        <li>use 8545 private network on metamask</li>
                        <li>in a seperate terminal windon run "geth attached"</li>
                        <li>eth.accounts to list your keys</li>
                        <li>upload in metamask using json type and files under keystroke folder</li>
                        <li>The balance of each account is of course available within that network, e.g. test or main</li>
                    </ul>
                    <p>In case of any issues, best to contact MetaMask team via http://slack.metamask.io</p>
                </div>
            </div>
        </div>
     </section>
     <section>
        <h2>My First Smart Contract: Greetings (Truffle 4)</h2> 
        <div class="content-section">
            <div class="content-title">
                 <h3>Deploying a smart contract without Truffle</h3>
                 <div class="content-details">
                    <p>In Ethereum, Smart Contract is a combination of code logic and data that is stored in a blockchain and executed by the Ethereum Virtual Machine (EVM)</p> 
                    <p>The EVM executes is Ethereum Byte Code, but as a developer you don't code in EVM Byte Code </p> 
                    <p>There are multiple high level programming languages that can be compiled in to the EVM byte code. Some are Vyper, Bamboo and Solidity</p>
                    <p>Solidity is widely used by the Etherum community.</p>
                    <p>Solidity is natively supported by Truffle framework</p>
                    <p>Basics of Solidity through Smart Contract "Greetings" with following features</p>
                    <ul>
                        <li>Contract state stores string message</li>
                        <li>When we instantiate the contract, the message is initialized with the string "I am ready"</li>
                        <li>Function called setGreeting will accept a string parameter to change the value of the message</li>
                        <li>Function called getGreetings will return the value of the message</li>
                    </ul>
                    <p>Prepare the environment</p>
                    <ul>
                        <li>Launch a terminal and create a folder to host our project</li>
                        <li>Use npm and Node.js to compile, deploy and test the application, so intialize and npm project "npm init"</li>
                        <li>Install the required JS libaries: "npm install web3@0.20.0 solc@0.4.18" </li>
                    </ul>
                    <p>Smart Contract used for this sample</p>
                    <ul>
                        <li>Empty file "greetings.sol" that will implement our contract "atom Greetings.sol"</li>
                        <li>".sol" convention for Solidity source files</li>
                        <li>"pragma solidity ^0.4.18;" every .sol file beginning</li>
                        <li>"contract Greetings {}" declare contract</li>
                    </ul>
                    <p>We will use Ganache as Ethereum node to deploy the smart contract</p>
                    <p>Load Web3 and Ganache</p>
                    <ul>
                        <li>In  terminal type "node" to start node console</li>
                        <li>Web3 = require("web3"): load web3 library</li>
                        <li>web3 = new Web3(new Web3.providers.HttpProvider("http://localhost:7545")): instantiate web3</li>
                        <li>web3.eth.accounts: list of all Ganache accounts</li>
                    </ul>
                    <p>Load Solidity Compiler</p>
                    <ul>
                        <li>solc = require("solc")</li>
                        <li>sourceCode = fs.readFileSync("Greetings.sol").toString()</li>
                    </ul>
                    <p>Compile Code</p>
                    <ul>
                        <li>compiledCode = solc.compile(sourceCode)</li>
                    </ul>
                    <p>Get the Application Binary Interface (ABI) of the contract</p>
                    <ul>
                        <li>ABI defines what functions are available in the contract and how to call them</li>
                        <li>contractABI = JSON.parse(compiledCode.contracts[":Greetings"].interface)</li>
                    </ul>
                    <p>Deploy Byte Contract to Ethereum Node</p>
                    <ul>
                        <li>greetingsContract = web3.eth.contract(contractABI): create contract factory based on the ABI: </li>
                        <li>byteCode = compiledCode.contracts[":Greetings"].bytecode :extract the byte code of the contract</li>
                        <li>greetingsDeployed = greetingsContract.new({data: byteCode, from: web3.eth.accounts[0], gas: 4700000}) :deploy the contract - this command signs and sends the transaction from the Ethereum node</li>
                    </ul>
                    <p>View Transaction in Ganache</p>
                    <ul>
                        <li>Access Contract Address:  greetingsDeployed.address</li>
                        <li>Get an instance of the contract: greetingsInstance = greetingsContract.at (greetingsDeployed. address)</li>
                       
                   
                        <li>greetingsInstance.getGreetings()</li>
                        <li>greetingsInstance.setGreetings("Hello ChainSkills!", {from: web3.eth.accounts[0]})</li>
                    </ul>
                 </div>
            </div>
            <div class="content-title">
                 <h3>Deploying a smart contract with Truffle</h3>
                 <div class="content-details">
                    <p>Previously we compiled and deployed Smart Contract manually through a node console using the Ethereum Wrapper Library (Web3 through JS) and Solidity Compiler (Solc)</p>  
                    <p>Painful and error prone to type all those commands when deploying a Smart Contract. To boost this development process, we need some accelerator, such as Truffle.</p> 
                    <p>Truffle is the most used development framework for Ethereum</p>
                    <p>Prepare the environment from the terminal</p>     
                    <ul>
                        <li>Create new directory "GreetingsTruffle"</li>
                        <li>Check if you have Truffle: "truffle version"</li>
                        <li>Initialize truffle: "truffle init" - you might get errors, so follow lecture</li>
                        <li>Launch atom to analyze the project: "atom ."</li>
                    </ul>
                    <p>Project Structure</p>
                    <ul>
                        <li>Contracts - will contain all Solidity contracts</li>
                        <li>Migrations.sol contract needs to be kept, it will help track which contracts have already been deployed</li>
                        <li>Migrations - contains the logic used during the deployment process</li>
                        <li>Test - contains test scripts used to test your contract</li>
                    </ul>
                    <p>Adapt the project for Greetings Smart Contract</p>
                    <ul>
                        <li>"Greetings.sol" same code as in the previous lesson</li>
                    </ul>
                    <p>Create Deployment Script</p>
                    <ul>
                        <li>"migrations/2_deploy_contracts.js" - very similar to the initial migration script</li>
                    </ul>
                    <p>Deployment</p>
                    <ul>
                        <li>1. Deploy Greetings Smart Contract to Ganache Core Ethereum development node bundled with truffle</li>
                        <li>In terminal start truffle development mode "truffle develop"</li>
                        <li>Truffle uses same accounts as Ganache due to the phrase</li>
                        <li>"truffle develop --log" connect to the running Ganache core node</li>
                    </ul>
                    <p>Truffle offers set of commands to build and deploy your contracts</p>
                     <p>Some of the commands try to avoid deploying a contract that was already deployed to a given network. Use "migrate --compile-all --reset" to make sure nothing is lost</p>
                     <ul>
                         <li>--compileAll forces recompilation of all our solidity files</li>
                         <li>--reset resets the state of the migrations contract and forces rerun of all migration scripts</li>
                    </ul>
                    <p>Once a contract is compiled its details are stored in build/Greetings.json</p>
                    <p>Interact with the Contract</p>
                    <ul>
                        <li>"Greetings.address"</li>
                        <li>"web3.eth.accounts"</li>
                        <li>"Greetings.deployed().then(function(instance) {app = instance; })" create instance</li>
                        <li>"app.getGreetings()"</li>
                        <li>"app.setGreetings("Hello Chainskills!", {from: web3.eth.accounts[0]})"</li>
                    </ul>
                    <p>"truffle develop" starts a Ganache develop node in the console.</p>
                     <p>Deploy the contract to Ganache instead of the Ethereum node bundled with Truffle;e</p>   
                     <p>Configure Truffle to add deployment network</p> 
                     <ul>
                         <li>Define network in truffle.js</li>
                         <li>Change node version "nvm use 10.16" </li>
                         <li>Force migration with the network "truffle migrate --compile-all --reset --network ganache"truffle migrate --compile-all --reset --network ganache
                        </li>
                     </ul>  
                     <p>Interact with the contract</p> 
                     <ul>
                         <li>"truffle console --network ganache"</li>
                     </ul>
                 </div>
            </div>
            <div class="content-title">
                 <h3>Blocks and transactions</h3>
                 <div class="content-details">        
                     <p>Blockchain is an immutable chain of blocks strongly linked together. Inside each block we have a set of transactions.</p>
                     <p>Transaction can describe a transfer of Ether between two accounts, the code of a smart contract or a call to a smart contract function that will change its state.</p>
                     <p>Ethereum transaction always has four fundamental fields: from, to, value, data/input.</p>
                     <p>In any case, both senders and recipients can be external accounts or other smart contracts.</p>
                     <p>Prepare the environment</p>
                     <ul>
                         <li>Navigate to GreetingsTruffle directory</li>
                         <li>Deploy contracts to Ganache network: "truffle migrate --compile-all --reset --network ganache"</li>
                         <li>Start new truffle console connected to Ganache "truffle console --network ganache"</li>
                     </ul>
                     <p>Transaction details</p>
                     <ul>
                         <li>Transaction hash - unique identifier for the transaction</li>
                         <li>From address - account that created the transaction (in our case Coinbase account)</li>
                         <li>Contract address - address of the deployed contract</li>
                         <li>Gas used - how much gas was used to create the contract</li>
                         <li>Transaction type - contact creation, contract call, ether transfer </li>
                         <li>Value - sent along with the contract</li>
                     </ul>
                     <p>Inspect the transaction</p>
                     <ul>
                         <li>Gas Price - set by default by truffle</li>
                         <li>Gas Limit - set by default by truffle </li>
                         <li>Mined in block - number of the block in which this transaction was mined</li>
                         <li>Tx Data - contains the byte code of our greetings contract </li>
                     </ul>
                     <p>Retreive more information than in Ganache by using web3.eth function in truffle console</p>
                     <ul>
                         <li>Copy transaction hash and go to terminal</li>
                         <li>web3.eth.gettransaction("TX_HASH")</li>
                         <li>nonce - increases by one with each transaction a given sender sends to the network. Used to create a unique address for our contract</li>
                         <li>blockHash - hash of the block containing the transaction</li>
                         <li>transactionIndex - index of the transaction inside the block</li>
                     </ul>
                     <p>Blocks</p>
                     <ul>
                         <li>In case of Ganache, with the automining setting on, a new block is automatically mined when new transaction is created.</li>
                         <li>We have four blocks plus the Genesis block that's generated when we start Ganache</li>
                         <li>Number of the block: also called block height </li>
                         <li>Date and time when the block was mined</li>
                         <li>Gas used - total gas used by transactions in this block</li>
                         <li>Number of transactions contained in this block</li>
                     </ul>
                     <p>Block mining intervals</p>
                     <ul>
                         <li>In Ethereum nothing prevents us from having empty blocks (with no transactions)</li>
                         <li>In proof of work consensus algorithm, the mining process is not only for mining transactions. It is also used as some sort of a clock for cryptocurrency creation</li>
                         <li>In a normal node implementation, blocks are produced at regular intervals of time, whether there are pending transactions or not</li>
                         <li>In Ganache, by default it is auto-mining - meaning blocks are only mined when there is one pending transaction, but we could also configure it to mine at regular intervals</li>
                     </ul>
                     <p>Additional information on blocks</p>
                     <ul>
                         <li>Gas Limit of the block</li>
                         <li>Hash of the block</li>
                         <li>List of all transactions in the block</li>
                     </ul>
                     <p>Additional information on blocks using web3.eth.getBlock command</p>
                     <ul>
                         <li>"web3.eth.getBlock("BLOCK_HASH")</li>
                         <li>parentHash - hash of the parent block that chains this block to the previous one</li>
                         <li>nonce - the mining nonce. the magic number that makes it possible to solve the consensus riddle</li>
                         <li>transactionRoot, stateRoot. receiptsRoot - Mekle tree rootes of the three trees referenced in each block</li>
                         <li>miner - the address of the miner who will receive the mining reward. In ganache, all blocks are automatically added to the in memory blockchain</li>
                         <li>difficulty - used to validate this block</li>
                         <li>total difficulty - sum of all the difficulties of all blocks until this point</li>
                         <li>size - size of the block expressed in bytes </li>
                     </ul>
                 </div>
            </div>
            <div class="content-title">
                 <h3>Gas</h3>
                 <div class="content-details"> 
                     <p>Usage of the blockchain costs money. This money is to reward miners who work hard to validate your transactions and append them to the blockchain</p>       
                     <p>When you send money to another account / deploy a smart contract / call a function on a smart contract, you have to pay for that. This cost is valued in GAS</p>
                     <p>In Ethereum, GAS is just a unit of complexity,  that is used to set the price of the code execution inside the Ethereum Virtual Machine. Each EVM operation, has a certain absolute complexity expressed in GAS</p>
                     <p>This complexity does not depend on the current value of Ether. Deploying Smart Contract or calling one of its functions, will cost a certain amount of gas, depending on the code complexity of the operation to perform </p>
                     <p>Correspondance between gas and the real price in Ether, is computed by using Gas Price</p>
                     <p>Prepare the environment</p>
                     <ul>
                         <li>Start Ganache</li>
                         <li>"truffle migrate --compile-all --reset --network ganache"</li>
                         <li>"truffle console --network ganache"</li>
                         <li>"truffle(ganache)> web3.fromWei(web3.eth.getBalance(web3.eth.accounts[0]),"ether").toNumber()" balance of the first account in ETH </li>
                     </ul>
                     <p>One account is considered your primary account - by default its the first one. Identify it "web3.eth.coinbase" (Coinabase / Etherbase) </p>
                     <p>Transaction Costs</p>
                     <ul>
                         <li>Each transaction used a certain amount of gas</li>
                         <li>Each transaction in Ganache has a gas price of 10^11 (100 000 000 000) WEI that corresponds to 0.0000001 ETH </li>
                         <li>https://converter.murkin.me</li>
                         <li>price = (gas usage) * (gas price)</li>
                     </ul>
                     <p>Gas you pay will be different depending on the network you use (test net / main net / private network) and complexity of your Smart Contract</p>
                     <p>Gas Limit</p>
                     <ul>
                         <li>Default value provided by Truffle: 6 721 975. It's different from the Gas really used</li>
                         <li>When we send transaction, we specifiy Gas Value and Gas Price</li>
                         <li>Gas limit - a security mechanism with upper limit as it is difficult to predict how much gas you would actually use</li>
                         <li>If Gas Limit is reached, process will stop</li>
                     </ul>
                     <p>Fees paid by these transactions</p>
                     <ul>
                         <li>Fees will go to the miner of the block containing your transaction as a reward for combining power</li>
                         <li>Miners are interested in transactions with Gas Price - if it is high, transaction will be processed faster</li>
                     </ul>
                     <p>See an impact of getGreetings() and setGreetings() transaction</p>
                     <ul>
                         <li>"Greetings.deployed().then(function(instance) {app = instance;})"</li>
                         <li>"app.getGreetings()"</li>
                         <li>"app.getGreetings({from: web3.eth.accounts[1]})"</li>
                         <li>Reading a value of a contract does not cost any gas, because it does require a transaction to be sent and is declared as view</li>
                         <li>"app.setGreetings("how is it going", {from: web3.eth.accounts[1]})" will cost money though</li>
                     </ul>
                     
                 </div>
            </div>
            <div class="content-title">
                 <h3>OpCodes</h3>
                 <div class="content-details">    
                     <p>Prepare the environment</p> 
                     <ul>
                         <li>Start Ganache</li>
                         <li>Open Terminal and navigate to Greetings Truffle</li>
                         <li>Redeploy everything "truffle migrate --compile-all --reset --network ganache"</li>
                         <li>Open console "truffle console --network ganache"</li>
                     </ul>   
                     <p>Inspect tranasctions inside Ganache</p>
                     <ul>
                         <li>TX DATA field shows the code of the smart contract deployed to the node</li>
                         <li>Value deployed is the binary byte code of the smart contract compiled by the solidity compiler thanks to Truffle</li>
                         <li>This code has to be executable by the Ethereum Virtual Machine that runs on every node in the network</li>
                         <li>As the node can be run on all operating systems (Linux, Mac, etc.) it should be executable on all the platforms</li>
                         <li>This byte code is decoded into series of Ethereum instructions called OpCodes</li>
                     </ul>
                     <p>OpCodes</p>
                     <ul>
                         <li>OpCodes compose the assembly language used by the EVM to execute the smart contract</li>
                         <li>https://etherscan.io/opcode-tool - online converter to decompile the binary byte code in corresponding op codes</li>
                         <li>Each upcode instruction has a corresponding cost in gas units depending on its complexity</li>
                     </ul>
                 </div>
            </div>
            <div class="content-title">
                 <h3>Sending ether</h3>
                 <div class="content-details"> 
                     <p>Sending Ether</p>  
                     <ul>
                         <li>Start the Truffle Ganache console</li>
                         <li>web3.eth.sendTransaction({from: web3.eth.accounts[0], to: web3.eth.accounts[1], value: web3.toWei(5,"ether")})</li>
                         <li>web3.fromWei(web3.eth.getBalance(web3.eth.accounts[0]),"ether").toNumber()</li>
                         <li>Price: 21'000</li>
                     </ul>    
                    <p>These transactions do not depend on the amount of the Ether you transfer</p> 
                 </div>
            </div>
        </div>
     </section>

     <section>
        <h2>ChainList Application - how do you design and develop a decenralized application? </h2> 
        <div class="content-section">
            <div class="content-title">
                 <h3>ChainList application preview</h3>
                 <div class="content-details">  
                     <p>Brand new decentralized application, called ChainList</p>  
                     <p>Similar to Craigslist, but in decentralized setup on Ethereum blockchain</p>   
                     <p>Panel for "events" that will list all the events of our articles</p>     
                     <p>Ability to "sell new articles"</p>    
                     <p>Ability to buy articles</p>
                 </div>
            </div>
            <div class="content-title">
                 <h3>Sell an article: smart contract</h3>
                 <div class="content-details">      
                    <p>Start creating fully decentralized application, called ChainList - decentralized marketplac on the Ethereum blockchain</p>  
                    <p>We will first create an application with which you can sell and buy just one item (later will add posibility for multiple items)</p>    
                    <p class="bold">Preparing the environment</p>  
                    <ul>
                        <li>Open terminal and create dedicated folder <u>ChainList</u></li>
                    </ul>  
                    <p class="bold">Create the project</p>
                    <ul>
                        <li>Can create in multiple ways, previously we used <u>truffle init</u></li>
                        <li>This time we will us <i>boxes</i> - boilerplate starter projects that you can use as a bases to build a real app. We will use <i>chainskills box</i> - custom box created for the course. Can be found <a href="https://github.com/chainskills/chainskills-box"> in this Github repository</a></li>
                        <li><u>truffle unbox chainskills/chainskills-box</u> unboxes the github repository and creates the boilerplate</li>
                    </ul>
                    <p class="bold">First iteration of the contract</p>
                    <ul>
                        <li>Allow us to sell one article by identifying the seller, articles name, it's description and price</li>
                        <li>Let us retreive the article by returning seller's address, articles name, it's description and price </li>
                    </ul>
                    <p class="bold">Creating new contract</p>
                    <ul>
                        <li>Create new file in <u>contracts</u> folder <u>ChainList.sol</u></li>
                        <li><u>pragma solidity ^0.4.18;</u> build the contract with solidiy compiler with the version</li>
                        <li>create <u>contract Chainlist {}</u></li>
                        <li>Define state variables: seller, name, description, price</li>
                        <li>Define a function  <u>sellArticle</u> to           sell an article</li>
                        <li>Define a function <u>getArticle</u> to get an article</li>
                    </ul>
                    <p class="bold">Modify the deployment process</p>
                    <ul>
                        <li>in <u>migrations</u> folder create a new file <u>2_deploy_contracts</u></li>
                        <li>Take the sample code from <u>initial_migration.js</u> file</li>
                    </ul>
                    <p class="bold">Choose between deploying with Ganache or Truffle</p>
                    <ul>
                        <li>When you deploy, you can choose to use Ganache or Truffle Develop as an in-memory node implementation </li>
                        <li>Ganache uses <u>5777</u> as network identifier, whereas Truffle <u>4447</u></li>
                        <li>Ganache uses <u>7545</u> as port, whereas Truffle <u>9545</u></li>
                        <li>For Ganache you can change those settings, for Truffle not</li>
                    </ul>
                    <p class="bold">In almost every lesson we will begin with starting Ganache</p>
                    <ul>
                        <li>Starts brand new in-memory implementation</li>
                        <li>Creates 10 accounts with 100 ETH each</li>
                        <li>Opens an RPC endpoint on localhost</li>
                        <li>Always uses the same seedphrase, accounts will always be the same </li>
                        <li>Normally to send transaction from ETH wallet, you need to unlock its private key. In ganache core they are automatically unlocked</li>
                        <li>You can always see the logs in the logs tab</li>
                    </ul>
                    <p class="bold">Deploy the contract</p>
                    <ul>
                        <li><u>truffle migrate --network ganache</u></li>
                        <li><u>--compile-all --reset</u> you can use it if you want to recompile everything, but you will loose your address </li>
                    </ul>
                    <p class="bold">Interact with the smart contract</p>
                    <ul>
                        <li><u>truffle console --network ganache</u></li>
                        <li><u>Chainlist.address</u> check address of chainlist contract (comes from <u>build/contracts/Chainlist.json</u></li>
                        <li>Check balances <u>web3.fromWei(web3.eth.getBalance(web3.eth.accounts[0]), "ether").toNumber()</u></li>
                    </ul>
                    <p class="bold">Get an instance of the contract</p>
                    <ul>
                        <li><u>Chainlist.deployed().then(function(instance){app = instance;})</u></li>
                        <li><u>app</u> contains JS object that contains everything we need about this contract</li>
                    </ul>
                    <p class="bold">Call functions</p>
                    <ul>
                        <li><u>app.getArticle()</u> everything initialized with zero or empty when no data</li>
                        <li><u>app.sellArticle("iPhone 7", "selling in order to buy iphone 8", web3.toWei(3,"ether"), {from: web3.eth.accounts[1]})</u></li>
                    </ul>
                </div>
            </div>
            <div class="content-title">
                 <h3 class>Sell an article: tests </h3>
                 <div class="content-details"> 
                     <p>Previously we saw how to create smart contract and implemented the function to sell and get an article. We deployed the contract to Ganache and called it's functions.</p>  
                     <p>One of the benefits of a blockchain is to make the transactions immutable in order to keep track of everything. The same principle applies to smart contracts deployed to the blockchain.</p> 
                     <p>Once smart contract is deployed, it cannot be changed. If there are bugs, you can disable it and deploy another instance of the smart contract (with new state and address). That's why it is important to test beforehand. </p>   
                    <p class="bold">Testing Strategies</p>
                    <ul>
                        <li>Use several testing environments before deploying it</li>
                        <li> Truffle Develop / Ganache are faster and have some testing features</li>
                        <li>Geth to create private Ethereum Network and check your solution on the same node implementation as the one used in production </li>
                        <li>Public Testnet - opportunity to share your solution with testers</li>
                    </ul>   
                    <p>In any of those solutions you can test using dedicated testing framework. Truffle bundles such a testing framework and provides two ways to test your contract: JavaScript (from client-side) and Solidity (within blockchain by simulating another contract interacting with yours) </p> 
                    <p>We will focus on JavaScript testing</p>
                    <p>Main goal of such testing is to increase the level of confidence and quality of your solution and to provide big production issues that might compromise credibility </p>
                    <p class="bold">Start writing tests</p>
                    <ul>
                        <li>Mocha as JS testing framework</li>
                        <li>Chai as development driven assertion library</li>
                        <li>Testing structure will have a test suite, containing several test cases to run</li>
                        <li>A lot of function calls are asynchronous</li>
                    </ul>
                    <p class="bold">Setup test suite</p>
                    <ul>
                        <li><u>tests/ChainListHappyPath.js</u> test suite for happy path scenario </li>
                        <li>loading the ChainList contract and wrapping in Truffle abstraction</li>
                        <li>test suite defined with a contract call. It gets a function that gets inserted list of accounts available on the node we are connected to  </li>
                    </ul>
                    <p class="bold">Define a test case</p>
                    <ul>
                        <li><u>it("should ...", function(){})</u></li>
                        <li>use <u>return Chainlist.deployed...</u> to access the contract data and then call a function on this data once more</li>
                        <li><u>assert.equal(data[])</u> Chai assertion to verify that everything is properly initialized</li>
                    </ul>
                    <p class="bold">Run the test suite</p>
                    <ul>
                        <li><u>truffle test --network ganache</u></li>
                        <li>This command recompiles your contracts, deploys them to ganache and runs all test suites under test directory</li>
                        <li>Each time a test suite is started, truffle deploys the last version of the contract to the node</li>
                        <li>Each test suite will have a unique contract address</li>
                        <li>Running a test suite will cost some gas for the deployment of the contract, therefore testing has to be done on the test environment</li>
                    </ul>
                    <p class="bold">New test case for sellArticle() function</p>
                    <ul>
                        <li>define variables to be added to the function</li>
                        <li>create new test case</li>
                        <li>call the <u>sellArticle()</u> function with all the params</li>
                        <li>this will create a transaction that is mined in a block</li>
                        <li>now you can call <u>getArticle()</u> to see if it was updated</li>
                        <li>call another function to check for assertions</li>
                    </ul>
                 </div>
            </div>
         
            <div class="content-title">
                 <h3>Sell an article: frontend preparation</h3>
                 <div class="content-details">   
                     <p>Typing commands in the console is a quick way to interact with the smart contracts, but end users will not interact with your Dapp, using console. In this lecture we will add the frontend part of Chainlist</p>    
                     <p>Truffle boxes offer application skeletons with a set of boilerplate elements already written for you</p>  
                     <p>In this course we use <u>Chainskills box</u> as a starting point for our Chainlist Dapp. This skeleton uses jQuery and Bootstrap</p>  
                     <p class="bold">Prepare for frontend</p>    
                     <ul>
                         <li>One of the things that the <u>chainlist box</u> did is initialize npm packages in <u>package.json</u> file describing some dependencies</li>
                         <li>Install all the npm dependencies <u>npm install</u></li>
                     </ul> 
                     <p class="bold">Project structure</p>
                     <ul>
                         <li><u>contracts</u> all contract source files. Migration contract should be kept </li>
                         <li><u>migrations</u> logic for the deployment process</li>
                         <li><u>node_modules</u> used by npm to store the packages required by the applications, such as <u>lightserver</u> - http server that will serve our web app when we will run <u>npm run dev</u></li>
                         <li><u>src</u> source code of our web application (includes <u>bootstrap</u>, <u>web3</u> and <u>truffle-contract</u> JavaScript libraries</li>
                         <li><u>test</u> contains test scripts for the contracts</li>
                         <li><u>truffle.js</u> configures our environment (more specifically the instances where we want to deploy our contracts). By default, it specifies Ganache environment </li>
                     </ul>
                     <p class="bold">Run sample application</p>
                     <ul>
                         <li><u>npm run dev</u> starts the LightServer and opens the browser </li>
                     </ul>
                     <p class="bold">Transform boilerplate to ChainList user interface</p>
                     <ul>
                         <li>Customize <u>package.json</u> file to give properties to your project</li>
                         <li>Customize <u>src/index.html</u> file (attached to lecture)</li>
                         <li><u>app.js</u> file contains the root of our JS application. Redefine the <u>init</u> function</li>
                         <li>Use jQuery to insert sample data of one article(could also use JavaScript itself)</li>
                         <li><u>css/app.css</u> new file with small changes</li>
                     </ul>
                 </div>
            </div>

            <div class="content-title">
                 <h3 class>Sell an article: display article in the frontend</h3>
                 <div class="content-details">    
                     <p>We are going to connect the web frontend to the contract backend in order to display the articles stored in the contract state. We will initialize our smart contract with default article that will be displayed in the frontend application  </p>         
                     <p class="bold">Prepare the environment</p>   
                     <ul>
                         <li>Start Ganache</li>
                         <li>If needed, run <u>npm install</u>to install all the dependencies</li>
                         <li>If needed, set the node version <u>nvm use 10.16</u></li>
                         <li>Open the project in the code editor</li>
                         <li>Run unit tests <u>truffle test --network ganache</u></li>
                         <li>Compile and deploy contracts to Ganache <u>truffle migrate --compile-all --reset --network ganache</u></li>
                         <li>Disable Metamask extension, because we will connect directly to the node without going through MetaMask</li>
                         <li><u>npm run dev</u> start the server on localhost:3000</li>
                     </ul>
                     <p class="bold">Web3 JavaScript usage</p>
                     <ul>
                         <li>We will use <u>web3</u> - javascript library used as a connector between the frontend and ethereum node</li>
                         <li>To establish this link, it is required to bind web3 to provider </li>
                         <li>If you would open it with the MetaMask extension enabled, an instance of web3 will be injected into the window object of your web page</li>
                         <li>In all the situations you will need to provide the address of the http provider hosting your ethereum node </li>
                     </ul>
                     <p class="bold">Adapt app.js to create an instance of web3 or to reuse an existing one</p>
                     <ul>
                         <li>Remove all the hardcoded calls</li>
                         <li>Work on the <u>initWeb3()</u> function: Initialize web3 - either reuse the provider of web3 object injected by Metamask (if already set) or create a new provider and plug it directly into our local node. Then can initalize new web3 object</li>
                         <li>Work on the <u>displayAcccountInfo()</u> function and call it</li>
                         <li>Initialize the connection to the contract by calling <u>initContract()</u> function</li>
                     </ul>
                     <p class="bold">Display Account Information - function </p>
                     <ul>
                        <li>define <u>App.account</u> variable, initialize it with 0x0</li>
                        <li>create <u>displayAccountInfo</u> function</li>
                        <li>call the <u>getCoinbase</u> asynchronous function to retreive the information about the current account selected by web3. This returns the account in a callback function</li>
                        <li>We store it in the <u>App</u> and display it on the page</li>
                        <li>Then we use this accounts address to retrieve its balance with the <u>getBalance()</u> asynchonous function, so we get the balance in the callback function again </li>
                        <li>We can display the account balance in the placeholder we defined in the HTML file after converting into the Ether</li>
                        <li>This code does not depend on the Chainlist contract initialization, so it can be done in parallel</li>
                     </ul>
                     <p class="bold">Create an instance of the contract and attach it to frontend</p>
                     <ul>
                         <li>Implement the <u>initContract()</u> function</li>
                         <li><u>$.getJSON("Chainlist.json"</u> load the contract JSON</li>
                         <li>Use the file to instantiate a truffle contract abstraction <u>TruffleContract(chainListArtifact)</u></li>
                         <li>Set the provider for contract <u>App.contracts.ChainList.setProvider(App.web3Provider)</u></li>
                         <li>Retreive the article from the contract <u> return App.reloadArticles()</u></li>
                     </ul>
                     <p class="bold">Adjust frontend</p>
                     <ul>
                         <li>work with <u>index.html</u> to remove the hard coded values for account and balance as they are coming from app.js</li>
                     </ul>
                     <p class="bold">Retrieve the article stored in our contract</p>
                     <ul>
                         <li>Function exposed by the ChainList contract is called <u>getArticle()</u></li>
                         <li>Set up function <u>reloadArticles()</u></li>
                         <li>Refresh account information because balance might have changed <u>App.displayAccountInfo()</u></li>
                         <li>Retreive the article placeholder and clear it <u>$("#articlesRow").empty</u></li>
                         <li>Call the <u>getArticle</u> contractt function <u>return instance.getArticle()</u> </li>
                         <li>Retreive article template and fill with data</li>
                         <li>Add article to <u>articlesRow</u></li>
                     </ul>
                     <p class="bold">Error handling</p>
                     <ul>
                         <li><u>catch(function(error) {}</u> and then <u>console.log</u> the error message</li>
                     </ul>
                     <p class="bold">Modify contract itself</p>
                     <ul>
                         <li><u>chainlist.sol</u> sourcefile</li>
                         <li>Define new constructor to initialize defult article <u>function Chainlist() public {}</u></li>
                         <li>Insert dummy data <u> sellArticle(.., .., ..);</u></li>
                         <li>Recompile and redeploy the contract <u>truffle migrate --compile-all --reset --network ganache
                        </u></li>
                     </ul>
                   
                 </div>
            </div>
           
           
            <div class="content-title">
                 <h3>Sell an article: from the frontend</h3>
                 <div class="content-details">    
                     <p class="bold">Prepare the environment</p> 
                     <ul>
                         <li>Start Ganache</li>
                         <li>In this lesson we will prepare to sell the article from the frontend, so we do not need the constructor that initializes default article anymore, so you can remove it from <u>chainlist.sol</u></li>
                         <li>From terminal, deploy the contract <u>truffle migrate --compile-all --reset --network ganache</u></li>
                     </ul>   
                     <p class="bold">Call <u>sellArticle()</u> function on the contract</p>   
                     <ul>
                         <li>Work in <u>app.js</u> and add it to the <u>App</u> object</li>
                         <li>Retreive the details of the article (based on <u>model-dialog</u> in <u>index.html</u>. Do it based on jQuery</li>
                         <li>If <u>_article_name</u> is empty or <u>_price</u> is 0, then there is nothing to sell, so simply <u>return false</u></li>
                         <li>Else call the <u>App.contracts.ChainList.deployed()</u> to get an instance of the deployed contract</li>
                         <li>Then call <u>instance.sellArticle(..)</u> function</li>
                         <li>After that call <u>App.reloadArticles()</u> to refresh articles</li>
                         <li>Handle the error with <u>catch</u></li>
                     </ul>   
                     <p class="bold">Connect the webpage to the new function</p>  
                     <ul>
                         <li>Work in <u>index.html</u></li>
                         <li>Change the onlick event for the button <u>onclick="App.sellArticle(); return false;"</u></li>
                     </ul>
                     <p class="bold">Test the application</p>
                     <ul>
                         <li>Run the web application <u>npm run dev</u></li>
                         <li>Create a dummy article</li>
                     </ul>
                     <p class="bold">Inspect the transaction</p>
                     <ul>
                         <li>Now <u>Block 5</u> should contain the transaction triggered by the <u>sellArticle()</u> function</li>
                         <li>You can see the <u>Gas Limit</u> determined by <u>sellArticle()</u> function, <u>Gas Used</u>, <u>Value</u> and <u>TX Data</u></li>
                         <li><u>TX Data</u> can be converted using <a href="https://codebeautify.org/hex-string-converter"> HEX String Converter</a></li>
                         <li>As you convert it you will get all the data sent along with the transaction</li>
                     </ul>
                 </div>
            </div>

            <div class="content-title">
                <h3>Sell an article: through MetaMask</h3>
                <div class="content-details">            
                    <p>In this lesson we are going to use Metamask Chrome extension</p>
                    <p>Thanks to Metamask we will have the ability to switch between different accounts to interact with our contract</p>   
                    <p class="bold">Prepare the environment</p> 
                    <ul>
                        <li>Naviate to <u>chainlist</u> directory</li>
                        <li>If needed, run <u>npm install</u></li>
                        <li>Start Ganache</li>
                        <li>Migrate the contract <u>truffle migrate --compile-all --reset --network ganache</u></li>
                        <li>Go to the Chrome Extensions and enable <u>Metamask</u> </li>
                        
                    </ul>
                    <p class="bold">Connect to Metamask</p>
                    <ul>
                        <li>Click Metamask and switch to private network, running on <u>http://localhost:7545</u> which is our Ganache node</li>
                        <li>If connection did not work, then navigate to the three dots option and select <u>Connected Sites</u></li>
                        <li>Connect manually</li>
                    </ul>
                    <p class="bold">Metamask and frontend connection</p>
                    <ul>
                        <li>In <u>app.js</u> we checked with <u>initWeb3</u> function if <u>web3</u> is already defined or not</li>
                        <li>When we enable Metamask, we are in the situation where <u>web3</u> is already defined, so in this case we use a provider already initialized by MetaMask</li>
                        <li>As we used the network <u>7545</u> the running provider is already connected to the Ganache instance</li>
                        <li>Now we can use the frontend and Metamask to switch between accounts</li>
                        <li>The account will be retreived vi the <u>web3.eth.getCoibnbase</u> call in the <u>displayAccountInfo</u>< function/li>
                    </ul>
                    <p class="bold">Sell an article</p>
                    <ul>
                        <li>Enter the account details</li>
                        <li>MetaMask intercepts the transaction that we want to submit to the blockchain and display dialog box to let us confirm this transaction</li>
                        <li>In this dialog you can change the gas limit and gas price</li>
                    </ul>
                    <p class="bold">Fixing network issue bug</p>
                    <ul>
                        <li>You might see a bug with an error from Metamask</li>
                        <li>To address it, you need to change the <u>NetworkID</u> of Ganache</li>
                        <li>in Ganache setting, increase the Network ID to <u>5778</u></li>
                        <li>If your restart Ganache, you need to migrate again</li>
                        <li>Switch the networks in metamask back and forth</li>
                    </ul>
                    <p>Metamask is quite unstable and some workaround might be needed</p>
                </div>
           </div>

           <div class="content-title">
                 <h3>Sell an article: smart contract with event</h3>
                 <div class="content-details">    
                     <p>In the previous lesson after we posted a new article for sale, we reloaded data from the contract to show the new article. That does not help other users connected to the same contract, who will not see the new article until they reload the page</p>   
                     <p>We should get notified whenever a new information is available, so the article appears automatically</p>   
                     <p>Ethereum provides a feature <u>events</u>, that are made exactly for this purpose. These events are informative messages stored in each Ethereum blocks transaction log</p>      
                     <p>Each event is associated to the address of the contract that triggered it</p>
                     <p>In this lecture, we will improve the chainlist contract by adding an event that will notify watchers that new article is available for sales. Then we will watch this event from the Truffle console</p>
                     <p class="bold">Prepare the environmment</p>
                     <ul>
                         <li>run <u>npm install</u> if needed</li>
                         <li>start Ganache</li>
                         <li>redeploy <u>truffle migrate --compile-all --reset --network </u></li>
                         <li>open Truffle console <u> truffle console --network ganache</u></li>
                         <li>run unit tests <u>test</u></li>
                     </ul>
                     <p class="bold">Trigger event when an article is ready for sale </p>
                     <ul>
                         <li>Update the <u>chainlist.sol</u> contract</li>
                         <li>Create new event <u> event LogSellArticle(..)</u></li>
                         <li>Trigger the event at the end of <u>sellArticle()</u> function by calling it <u>LogSellArticle(seller, name, price)</u></li>
                     </ul>
                     <p class="bold">Prepare the console</p>
                     <ul>
                         <li>Redeploy <u>migrate --compile-all --reset</u></li>
                         <li>Get an instance of the deployed contract <u>Chainlist.deployed().then(function(instance){app = instance;})</u></li>
                         <li>Use the <u>app</u> variable to interact with the contract</li>
                     </ul>
                     <p class="bold">Watch the event</p>
                     <ul>
                         <li>Define new sellEvent variable <u>var sellEvent = app.LogSellArticle({},{fromBlock: 0, toBlock:"latest"}).watch(function(error, event) {console.log(event);})</u></li>
                    </ul>
                    <p class="bold">Sell an article</p>
                    <ul>
                         <li> <u>app.sellArticle("article 1", "Description of article 1", web3.toWei(10, "ether"), {from: web3.eth.accounts[1]})</u></li>
                         <li>Immediately we see a transaction reciept as before. It contains <u>logs</u> field with all events triggered by that transaction</li>
                         <li>We also see the console log produced by the call to the callback function we defined in the <u>watch</u>. This has details about the event </li>
                         <li><u>args</u> contain the arguments passed in the <u>LogSellArticle</u> function</li>
                     </ul>
                     <p class="bold">Stop watching events</p>
                     <ul>
                         <li>Need to call <u>sellEvent.stopWatching()</u> </li>
                         <li>If you sell the article again you will not get any console.logs</li>
                     </ul>
                     <p class="bold">Improve the test suite to check the event log</p>
                     <ul>
                         <li>go to <u>ChainListHappyPast.js</u> suite</li>
                         <li>add a new test case</li>
                         <li>call the <u>sellArticle(..)</u></li>
                         <li>test for the length of <u>receipt.logs.length</u></li>
                         <li>test for all the arguments <u>receipt.logs[0].args._seller</u></li>
                         <li>in the truffle console run <u>test</u> again</li>
                     </ul>
                     <p class="bold">Improve which blocks you are watching</p>
                     <ul>
                         <li>Dont watch from block zero to block last (not good practice)</li>
                         <li>For our app we are only interested for watching the latest event triggered</li>
                         <li>First, stop watching events <u>sellEvent.stopWatching()</u></li>
                         <li>Redeploy the contract <u>migrate --compile-all --reset</u></li>
                         <li>Get a new instance <u>Chainlist.deployed().then(function(instance){app = instance;})</u></li>
                         <li>Watch only last event <u>var sellEvent = app.LogSellArticle({},{}).watch(function(error, event) {console.log(event);})</u> - it is there by default to watch the latest</li>
                         <li>Sell article <u>app.sellArticle("article 1", "Description of article 1", web3.toWei(10, "ether"), {from: web3.eth.accounts[1]})</u></li>
                     </ul>
                 </div>
            </div>

            <div class="content-title">
                <h3>Sell an article: events in the frontend</h3>
                <div class="content-details">     
                    <p>In the previous lesson we declared and triggered an event in our contract and improved our test suite to ensure that we are able to watch this event. We saw how to watch this event in the truffle console as well.</p>  
                    <p>In this lecture we are going to watch this event from the frontend application. When the <u>logSellArticle</u> is triggered, we retreive the article from the contract and display it </p>     
                    <p>We will also show the events themselves in the page</p>  
                    <p class="bold">Prepare the environment</p>  
                    <ul>
                        <li>make sure you are in the <u>chainlist</u> directory</li>
                        <li>run <u>npm install</u> in case we need it</li>
                        <li>start <u>ganache</u> to get a fresh node</li>
                        <li>run unit tests <u>truffle test --network ganache</u></li>
                        <li>deploy the smart contract <u>truffle migrate --compile-all --reset --network ganache</u></li>
                    </ul>
                    <p class="bold">Listen to events triggered by the contract</p>
                    <ul>
                        <li><u>src/js/app.js</u></li>
                        <li><u>listenToEvents()</u> function</li>
                        <li>call the <u>instance.LogSellArticle()</u> function</li>
                        <li>after that call the <u>App.reloadArticles()</u> function to refresh articles</li>
                        <li>if we do not have any error, then we add the events that we get to list of events that will be displayed in the page <u> $("#events").append('li...')</li...></u></li>
                        <li>call this function in the <u>initContract()</u> function <u>App.listenToEvents()</u></li>
                    </ul>
                    <p class="bold">Adapt the frontend</p>
                    <ul>
                        <li>Add a collapsable <u>button</u> to display <u>Events</u></li>
                        <li>These events should be put in after the <u>panel-heading div</u> as a <u>ul</u></li>
                    </ul>
                    <p class="bold">Testing your work</p>
                    <ul>
                        <li>Go to the frontend and enable / fix your <u>metamask</u></li>
                        <li>Attempt to sell an article</li>
                        <li>If nothing happens, it is a bug related to Event Fetching and Synchronization of MetaMask - quit Chrome and try again</li>
                    </ul>
                </div>
           </div>

           <div class="content-title">
            <h3>Deploy chainlist to private network</h3>
                <div class="content-details">      
                    <p>So far we developed few features of the chainlist dapp, using narative 3 step development cycle: add a feature to the contract, test the features by interacting with it in a truffle console and then unit tests. Last, deploy the contract to Ganache and create the frontend for the new feature</p>     
                    <p>Once in a while, you should deploy contracts to a real blockchain implementation in order to test those contracts and frontend as close as possible to the main net.</p>  
                    <p>The blockchain data in development nodes is kept in memory, each block contains only one transaction, transactions are mined almost instantly, all accounts are unlocked by default. </p>   
                    <p>In this lesson, we will deploy our chainlist contract to <u>Geth</u> private node that we configured earlier in this course.</p>
                    <p class="bold">Prepare the environment</p>
                    <ul>
                        <li>open terminal and go to <u>ChainSkills/private</u> directory</li>
                        <li>run the startnode script <u>./startnode.sh</u></li>
                        <li>every time you start your private node, check the first lines of the logs</li>
                        <li>in new terminal go to the <u>chainlist</u> project, run <u>npm install</u></li>
                        <li>run tests <u>truffle test</u> without specifying the network</li>
                        <li>unit tests use virtual node - a <u>Ganache</u> core node that is started specifically for running tests and shut down when tests are complete. This way, tests are run against contracts that are deployed on their own dedicated node and they do not interfere with the contract instance that you deploy with <u>truffle migrate</u></li>
                        <li>note, that if you define a network called <u>development</u> in <u>truffle.js</u> it will be used as a default network for <u>truffle test</u></li>
                    </ul>
                    <p class="bold">Deploy the chainlist contract to private network</p>
                    <ul>
                        <li>open the project in your code editor, because we need to customize the configuration a little bit</li>
                        <li>add a new network configuration to <u>truffle.js</u>: "chainskills"</li>
                        <li>in terminal run <u>truffle migrate --compile-all --reset --network chainskills</u></li>
                        <li>it takes longer than in memory node, because Geth has to actually mine the blocks containing the transactions and in our case it has to wait for each transaction to be mined before it can send the next one</li>
                        <li>we are deploying contracts to our private node, so we are creating transactions, but we said that accounts are supposed to be locked in a geth node</li>
                    </ul>
                    <p class="bold">Check the connection</p>
                    <ul>
                        <li>open console <u>truffle console --network chainskills</u> connected to the chainskills network</li>
                        <li>call <u>web3.eth.accounts</u> to list the accounts on this node and we see 3 accounts that we defined when we created our private node</li>
                    </ul>
                    <p class="bold">Customize the account for deployment and understand unlocking</p>
                    <ul>
                        <li>copy the second account</li>
                        <li>in <u>truffle.js</u> customize the account from which contracts are deployed</li>
                        <li>redeploy the contract <u>truffle migrate --compile-all --reset --network chainskills
                        </u> - you will get an error: <u>Error: authentication needed: password or unlock </u></li>
                        <li>when there is no <u>from</u> address mentioned anywhere, the coinbase account (the first account on the node) is used to deploy contracts by default</li>
                        <li>in our startnode script we are unlocking the account 0 in the password stored in a file <u>--unlock 0 --password ~/code/ievaaleksandravica/web3-development/ChainSkills/private/password.sec</u></li>
                        <li>this is needed because we are using this account to mine new blocks and it needs to be unlocked in order to mine</li>
                        <li>that is why we could deploy the contracts from the private node</li>
                    </ul>
                    <p class="bold">Unlock the second account</p>
                    <ul>
                        <li>in <u>startnode.sh</u> script we are making <u>--http.api eth,web3,personal,net</u> available</li>
                        <li>the <u>personal</u> module contains the function we need to unlock the account</li>
                        <li>open <u>truffle console --network chainskills</u> where truffle is connecting to the private node via the rpc endpoint</li>
                        <li>unlock the account <u>web3.personal.unlockAccount(web3.eth.accounts[1], password, duration)</u></li>
                        <li>migrate the conract again <u>migrate --compile-all --reset</u></li>
                        <li>if you still get an error  for insufficient funds, transfer some <u>web3.fromWei(web3.eth.getBalance(web3.eth.accounts[1]),"ether")</u></li>
                        <li>quit truffle console <u>.exit</u></li>
                        <li>remove the <u>from</u> field from <u>truffle.js</u></li>
                    </ul>
                    <p class="bold">Connect to metamask</p>
                    <ul>
                        <li>redeploy the contract <u>truffle migrate --compile-all --reset --network chainskills
                        </u> </li>
                        <li>run the application <u>npm run dev</u></li>
                        <li>connect to <u>metamask</u></li>
                        <li>switch to <u>port 8545</u></li>
                        <li>import the private accounts again if needed</li>
                        <li>try to sell an article</li>
                        <li>if you get an error, change <u>network id</u> for the port to <u>4224</u></li>
                    </ul>
                </div>
            </div>

            <div class="content-title">
                <h3>Buy an article: smart contract</h3>
                    <div class="content-details">
                        <p>In this lesson, we will add the possibility for user to buy an article from Chainlist and pay from his wallet</p>   
                        <p class="bold">Prepare the environment</p>  
                        <ul>
                            <li>open terminal and navigate to <u>chainlist project</u></li>
                            <li>run <u>npm install</u> if needed</li>
                            <li>open project in code editor</li>
                            <li>start <u>ganache</u></li>
                            <li>open truffle console <u>truffle console --network ganache</u></li>
                            <li>run tests <u>test</u></li>
                        </ul> 
                        <p class="bold">Buy feature description</p>     
                        <ul>
                            <li>ensure there is an article to buy</li>
                            <li>allowing somebody to buy it</li>
                            <li>make sure that article is still available for purchase</li>
                            <li>the buyer cannot be the seller</li>
                            <li>value passed to the function must be the same as the article price</li>
                            <li>only then the buyer pays the seller and once the purchase have been made, we trigger an event to inform watchers that the article was purchased</li>
                        </ul> 
                        <p class="bold">Implement the buy feature</p>  
                        <ul>
                            <li>work with <u>chainlist.sol</u></li>
                            <li>add new state variable to store the address of the  buyer <u>address buyer</u></li>
                            <li>declare a new event <u>event LogBuyArticle()</u></li>
                            <li>both <u>seller</u> and <u>buyer</u> are <u>indexed</u> which will make it possible for both the buyer and the seller to watch only the events that are specific to them </li>
                            <li>add a function to <u>buyArticle()</u> with qualifier <u>payable</u> - means this function may receive ether from its caller</li>
                        </ul>
                        <p class="bold">Feature verification</p>
                        <ul>
                            <li>check if there is an article for sale bu checking <u>require(seller != 0x0)</u></li>
                            <li>check that the article has not been sold yet <u> require(buyer == 0X0)</u></li>
                            <li>do not allow seller to buy its own article <u>require(msg.sender != seller)</u></li>
                            <li>check that the value sent corresponds to the price of article <u>require(msg.value == price)</u></li>
                        </ul>
                        <p class="bold">Proceed with the transaction</p>
                        <ul>
                            <li>keep buyers information <u>buyer = msg.sender</u></li>
                            <li>the buyer can pay the seller <u>seller.transfer(msg.value)</u></li>
                            <li>trigger the event <u>LogBuyArticle(seller, buyer, name, price)</u></li>
                        </ul>
                        <p class="bold">Some notes about the above code</p>
                        <ul>
                            <li>There are several ways to interupt the contract execution <u>throw</u>, <u>assert</u>, <u>require</u>, <u>revert</u></li>
                            <li>They all have the same consequences when condition fails
                                <ul>
                                    <li>value gets refunded</li>
                                    <li>state changes reverted</li>
                                    <li>function execution is interrupted</li>
                                    <li>gas spent up to to that point is not refunded</li>
                                    <li><u>revert</u> opcode returned</li>
                                </ul>
                            </li>
                            <li>However, each of them have different purposes
                                <ul>
                                    <li><u>throw</u> legacy</li>
                                    <li><u>assert</u> internal errors</li>
                                    <li><u>require</u> test preconditions</li>
                                    <li><u>revert</u> imperative exceptions</li>
                                </ul>
                            </li>
                            <li><u>address</u> type has two methods to send value to an account: <u>send</u> and <u>transfer</u>. <u>send</u> returns to returns true or false, so you have to check it. <u>transfer</u> automatically throws a <u>revert</u> error, if the transaction fails</li>
                            <li>when you try to divide by zero or access array with out of bounds index it will trigger an <u>assert</u> style exception</li>
                            <li>any smart contract has its own crypto currency balance just like any other account</li>
                            <li>in ethereum, there are two kinds of accounts: external accounts, which have a key pair and can be used by human users and contract accounts, which are linked to deployed contracts </li>
                            <li>when you attach <u>value</u> to a contract, you are effectively transferring balance from the sender to the balance of the corresponding contract</li>
                            <li>then the contract can spend this balance by sendingor transferring it to other account</li>
                        </ul>
                        <p class="bold">Retrieve address of the buyer</p>
                        <ul>
                            <li>adjust <u>getArticle()</u> function <u> address _buyer</u></li>
                        </ul> 
                        <p class="bold">Test the current setup</p>
                        <ul>
                            <li>in terminal <u>truffle console</u> migrate <u>migrate --compile-all --reset</u></li>
                            <li>get an instance of the deployed contract <u>Chainlist.deployed().then(function(instance) {app = instance;})</u></li>
                            <li>check balances <u>web3.fromWei(web3.eth.getBalance(web3.eth.accounts[0]), "ether").toNumber()</u></li>
                            <li>call <u>app.getArticle()</u> function - everything is initialized to zero</li>
                            <li>sell an article <u>app.sellArticle("article 1", "description for article 1", web3.toWei(10, "ether"), {from: web3.eth.accounts[1]})</u></li>
                            <li>check the data stored in the contract <u>app.getArticle()</u> - buyer is zero (there is none yet) </li>
                        </ul> 
                        <p class="bold">Buy an article</p>
                        <ul>
                            <li>Buy article from account with index <u>2</u></li>
                            <li>Watch the buy article event <u>var buyEvent = app.LogBuyArticle({_seller: web3.eth.accounts[1]}, {}).watch(function(error, event){ console.og(event); })</u></li>
                            <li>buy the article <u>app.buyArticle({from: web3.eth.accounts[2], value: web3.toWei(10, "ether")})</u></li>
                        </ul>
                        <p class="bold">Interrupted <u>buyArticle</u> function</p>
                        <ul>
                            <li>in terminal <u>truffle console</u> migrate <u>migrate --compile-all --reset</u></li>
                            <li>get an instance of the deployed contract <u>Chainlist.deployed().then(function(instance) {app = instance;})</u></li>
                            <li>sell an article <u>app.sellArticle("article 1", "description for article 1", web3.toWei(10, "ether"), {from: web3.eth.accounts[1]})</u></li>
                            <li>call <u>app.getArticle()</u> function</li>
                            <li>buy the article <u>app.buyArticle({from: web3.eth.accounts[2], value: web3.toWei(5, "ether")})</u></li>
                        </ul>
                        <p class="bold">Truffle debugger</p>
                        <ul>
                            <li>let's you inspect step by step to see what happened exactly - where was the exception was thrown</li>
                            <li>in <u>ganache</u> transactions you can see that last transaction has a <u>value</u></li>
                            <li>copy transaction path of the failing transaction</li>
                            <li>in console type <u>debug "tx hash"</u></li>
                            <li>it will switch the prompt to <u>debug(ganache: ...)</u></li>
                            <li>you can navigate it step by step by typing "enter" to get to your needed function</li>
                            <li>once you get to the error, it will be displayed to you.</li>
                        </ul>
                    </div>
            </div>
            <div class="content-title">
                <h3>Buy an article: tests</h3>
                    <div class="content-details"> 
                        <p>In this lecture we will test the <u>buy article</u> feature by improving the <u>happyPath</u> test suite and ensuring that tests cover exceptions.</p>    
                        <p class="bold">Prepare the environment</p>
                        <ul>
                            <li>change your node version <u>nvm use 10</u></li>
                            <li>make sure you are in the <u>chainlist</u> directory</li>
                            <li>in this lesson, we will not need the <u>npm run dev</u></li>
                            <li>open the project in your code editor</li>
                            <li>start <u>ganache</u> - it will be used as our running node</li>
                            <li>run <u>truffle console --network ganache</u> to connect the truffle console to our running ganache node</li>
                            <li>run current tests <u>test</u> - we will now get failing tests, because we updated our smart contract, but not the test suite</li>
                        </ul>    
                        <p class="bold">Update <u>ChainListHappyPath</u> test suite</p>  
                        <ul>
                            <li>open the <u>ChainListHappyPath.js</u> file</li>
                            <li>declare new variables to identify the buyer and balances before and after buying the article: buyer, sellerBalanceBeforeBuy, sellerBalanceAfterBuy, buyerBalanceBeforeBuy, buyerBalanceAfterBuy</li>
                            <li>update test case <u>should be initialized with empty values</u> - shift the data elements and add a new one for: buyer must be empty</li>
                            <li>update test case <u>should sell an article</u> - shift the data elements and add a new one for: buyer must be empty</li>
                        </ul>  
                        <p class="bold">Add new test case for <u>should buy an article</u></p>   
                        <ul>
                            <li>setup the test case and first retreive the <u>chainListInstance</u> as in all other test cases</li>
                            <li>keep track of balances before selling the articles</li>
                            <li>call <u>chainListInstance.buyArticle()</u> to buy the article</li>
                            <li>use a <u>reciept</u> from the callback function and use <u>assert</u>  test similar cases as for <u>sellArticle</u> test case</li>
                            <li>record balances of buyer and seller after the buy</li>
                            <li>check the effect with <u>assert</u> of the buy on balances of buyer and seller, accounting for gas</li>
                            <li>return <u>return chainListInstance.getArticle()</u> to chain another promise on that</li>
                            <li>check that now we have a   <u>buyer</u></li>
                        </ul>
                        <p class="bold">Description of above implemented test case</p>
                        <ul>
                            <li>Tests that the <u>buyArticle()</u> function triggers the right event with the right data</li>
                            <li>Tests the effects that the call to <u>buyArticle</u> has on the balances for the buyer and seller, accounting for the gas</li>
                            <li>Tests the modification that the <u>buyArticle</u> makes on the contract state</li>
                            <li>Test case will only pass if it is run after <u>should sell an article</u></li> 
    
                        </ul>
                        <p class="bold">Run tests</p>
                        <ul>
                            <li>run <u>test</u> from the console and fix any issues</li>
                        </ul>
                        <p class="bold">Add new test suite to test exceptions</p>
                        <ul>
                            <li>new file <u>ChainListExceptions.js</u></li>
                            <li>this test suite will test the exceptions thrown by the <u>buyArticle</u> function when the requirements are not fulfilled</li>
                            <li>Basis of the test suite will be very similar to the <u>happyPath</u> test suite</li>
                        </ul>
                        <p class="bold">Configure the test suite</p>
                        <ul>
                            <li>load the contract to be tested</li>
                            <li>setup the test suite</li>
                            <li>start with defining the variables you will need in the test cases</li>
                            <li>add test cases to ensure that our <u>buy article</u> implementation throws the right exceptions </li>
                            <li>to make sure that something fails, chain a promise and use <u>assert.fail</u> to test that it fails and then chain a <u>catch(function(error){assert(true);})</u>. After that call the <u>getArticle()</u> function to make sure that it was not affected</li>
                            <li>Buyer tries to buy an article, when there is no article for sale yet: <u>should throw an exception if you try to buy an article when there is no article for sale yet</u></li>
                            <li>run seperate test file <u>test test/ChainListExceptions.js</u></li>
                        </ul>
                        <p class="bold">Test what happens when you are trying to buy your own article</p>
                        <ul>
                            <li><u>should throw an exception if you try to buy your own article</u></li>
                            <li>in the <u>chainlist</u> contract implementation, buyer cannot be the same as seller </li>
                            <li>first call the <u>chainListInstance.sellArticle()</u> function</li>
                            <li>then try to buy it from the sellers account <u>chainListInstance.buyArticle({from: seller})</u></li>
                        </ul>
                        <p class="bold">Test what happens when you are trying to buy an article for the wrong value</p>
                        <ul>
                            <li><u>should throw an exception if you try to buy an article for wrong value</u></li>
                            <li>logic is very similar to the previous case, just different <u>buyArticle()</u> params</li>
                        </ul>
                        <p class="bold">Test what happens when you are trying to buy an article that was already sold</p>
                        <ul>
                            <li><u>should throw an exception if you try to buy an article that was already sold</u></li>
                            <li>need to buyArticle twice</li>
                        </ul>
                    </div>
            </div>

            <div class="content-title">
                <h3>Buy an article: frontend</h3>
                    <div class="content-details">
                        <p>In this lesson, we we will add frontend to buy an article</p>      
                        <p class="bold">Prepare the environment</p>     
                        <ul>
                            <li>in terminal, navigate to <u>chainlist</u> directory</li>
                            <li>install the npm dependencies <u>npm install</u></li>
                            <li>run the tests <u>truffle test</u></li>
                            <li>start <u>ganache</u>. at this point, we want to avoid any issues with <u>metamask</u> later, so we will increase the network identifier to <u>5778</u></li>
                            <li>deploy the contract <u>truffle migrate --compile-all --reset --network ganache</u></li>
                            <li>open the project in your code editor</li>
                        </ul> 
                        <p class="bold">Adjustments to the frontend to match the updates we made to the <u>getArticle</u> function </p>  
                        <ul>
                            <li>in terminal run <u>npm run dev</u></li>
                            <li>in metamask, switch to <u>localhost:7545</u></li>
                            <li>quit chrome and start it again. Import Ganache accounts if needed</li>
                            <li>try to sell an article. an error will be thrown for <u>description</u> in the console - this is because we changed <u>getArticle</u> but not the related code in <u>app.js</u></li>
                        </ul>  
                        <p class="bold">Adjust frontend to have button and buyer</p>
                        <ul>
                            <li>work in <u>index.html</u> in <u>articleTemplate</u> section</li>
                            <li>add area for <u>article-buyer</u></li>
                            <li>create a new div and button with onclick event <u>onclick="App.buyArticle(); return false;"</u></li>
                        </ul>
                        <p class="bold">Adjust script and update <u>reloadArticles</u> function</p>
                        <ul>
                            <li>work in <u>app.js</u></li>
                            <li>extract <u>price</u></li>
                            <li>shift <u>indexes</u> of other article elements</li>
                            <li>add <u>buyer</u> data: <u>articleTemplate.find(".btn-buy").attr('data-value', price)</u></li>
                            <li>with <u>if</u> conditions, check if there is a buyer</li>
                            <li>hide or show the <u>buy</u> button, depending on the situation</li>
                        </ul>
                        <p class="bold">Add a new function for <u>buyArticle()</u></p>
                        <ul>
                            <li>this function will be called when we hit the <u>buy</u> button - it will retreive the article prices stored as a data attribute on the button and call <u>buyArticle</u> function exposed by the contract </li>
                            <li>retreive price <u> var _price = parseFloat($(event.target).data("value"))</u></li>
                            <li>call the <u>buyArticle()</u> function</li>
                            <li>catch if there are any errors <u>console.error(error)</u></li>
                        </ul>
                        <p class="bold">Adjust the <u>listenToEvents</u> function</p>
                        <ul>
                            <li>add another listener to <u>logBuyArticle</u> function</li>
                        </ul>
                        <p class="bold">Test the implementation</p>
                        <ul>
                            <li>If we go back to the page, the article we sold, should be displayed correctly</li>
                            <li>Switch accounts and you should see a <u>buy</u> button</li>
                            <li>Attempt to buy. Metamask will ask to confirm the transaction with associated amount</li>
                        </ul>
                    </div>
            </div>

            <div class="content-title">
                <h3>List of articles: smart contract</h3>
                    <div class="content-details">      
                        <p class="bold"></p>          
                    </div>
            </div>

            <div class="content-title">
                <h3 class="empty">List of articles: tests</h3>
                    <div class="content-details">                
                    </div>
            </div>

            <div class="content-title">
                <h3 class="empty">List of articles: frontend</h3>
                    <div class="content-details">                
                    </div>
            </div>

            <div class="content-title">
                <h3 class="empty">Smart contract deactivation</h3>
                    <div class="content-details">                
                    </div>
            </div>

            <div class="content-title">
                <h3 class="empty">Function modifiers</h3>
                    <div class="content-details">                
                    </div>
            </div>

            <div class="content-title">
                <h3 class="empty">Smart contract inheritance</h3>
                    <div class="content-details">                
                    </div>
            </div>

            <div class="content-title">
                <h3 class="empty">Deploying the frontend</h3>
                    <div class="content-details">                
                    </div>
            </div>
            <div class="content-title">
                <h3 class="empty">Deploying smart contracts to the Rinkeby test net</h3>
                    <div class="content-details">                
                    </div>
            </div>
            <div class="content-title">
                <h3 class="empty">Deploying smart contracts to the main net</h3>
                    <div class="content-details">                
                    </div>
            </div>
            <div class="content-title">
                <h3 class="empty">Deploying to a test node with an Infure remote node</h3>
                    <div class="content-details">                
                    </div>
            </div>
        </div>
     </section>
     
     <section>
        <h2>Section Title</h2> 
        <div class="content-section">
            <div class="content-title">
                 <h3 class="empty">Subsection Title</h3>
                 <div class="content-details">                
                 </div>
            </div>
            <div class="content-title">
                <h3 class="empty">Subsection Title</h3>
                <div class="content-details">                
                </div>
           </div>
        </div>
        
     </section>
     <script src="/script.js"></script>
</body>
</html>